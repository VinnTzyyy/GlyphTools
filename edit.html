<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Glyph Editor</title>
    <style>
        @font-face {
            font-family: 'MinecraftTen';
            src: url('font/MinecraftTen.ttf') format('truetype');
        }
        :root {
            --bg: #1a1a1a; 
            --text: white; 
            --container-bg: #222; 
            --tool-bg: #333;
            --tool-hover: #444; 
            --tool-active: #4e54c8; 
            --border-color: #404040;
        }
        * { box-sizing: border-box; }

        body {
            background-color: var(--bg); color: var(--text);
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            margin: 0;
            -webkit-font-smoothing: antialiased; -moz-osx-font-smoothing: grayscale;
            touch-action: none;
        }
        
        .editor-header {
            background: linear-gradient(270deg, #8A2BE2, #87CEEB, #6a11cb, #87CEEB);
            background-size: 400% 400%;
            animation: gradientAnimation 12s ease infinite;
            
            padding: 0 20px; 
            height: 60px;
            display: flex; 
            justify-content: flex-start; /* Rata Kiri */
            align-items: center;
            border-bottom: 1px solid var(--border-color); 
            user-select: none;
            box-shadow: 0 2px 10px rgba(0,0,0,0.3);
        }
        
        @keyframes gradientAnimation {
            0% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
            100% { background-position: 0% 50%; }
        }

        .editor-header h1 { 
            font-family: 'MinecraftTen', sans-serif; 
            font-size: 1.5em; 
            margin: 0; 
            color: white;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
            letter-spacing: 1px;
        }
        
        .editor-main {
            display: flex; flex-direction: column; align-items: center;
            gap: 20px; padding: 20px; user-select: none;
        }

        .editor-section {
            width: 100%; max-width: 552px;
            background-color: var(--container-bg); border-radius: 12px;
            padding: 20px; box-shadow: 0 0 30px rgba(0,0,0,0.5);
            display: flex; flex-direction: column;
            justify-content: center; align-items: center;
        }
        
        .canvas-container {
            padding: 0;
            border: 4px solid #333;
            background-color: #333;
            overflow: hidden;
        }
        
        #canvas-grid-wrapper {
            width: 512px; height: 512px;
            max-width: 90vw; max-height: 90vw;
            position: relative;
            box-shadow: 0 0 20px rgba(0,0,0,0.5);
            
            background-color: #ffffff; /* Warna Pixel 1 (Putih) */
            
            background-image: conic-gradient(
                #d0d0d0 90deg,  /* Warna Pixel 2 (Abu) */
                transparent 90deg 180deg,
                #d0d0d0 180deg 270deg,
                transparent 270deg
            );
            
            background-size: calc(var(--pixel-scale, 32px) * 2) calc(var(--pixel-scale, 32px) * 2);
            background-position: 0 0;
        }

        #canvas-grid-overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none;
            background-image:
                repeating-linear-gradient(#00000022 0 1px, transparent 1px 100%),
                repeating-linear-gradient(90deg, #00000022 0 1px, transparent 1px 100%);
            background-size: var(--pixel-scale, 32px) var(--pixel-scale, 32px);
            display: none; /* Diatur oleh JS */
            z-index: 5;
        }

        #editor-canvas {
            width: 100%; height: 100%;
            image-rendering: pixelated; /* Wajib agar gambar tajam */
            cursor: crosshair;
            position: relative;
            z-index: 10;
        }
        
        .tools-container { align-items: center; }
        .toolbar { display: flex; flex-wrap: wrap; justify-content: center; gap: 10px; }
        .tool-btn {
            background-color: var(--tool-bg); border: 2px solid transparent; color: var(--text);
            width: 50px; height: 50px; border-radius: 8px; cursor: pointer;
            transition: background-color 0.2s; display: grid; place-items: center;
        }
        .tool-btn:hover { background-color: var(--tool-hover); }
        .tool-btn.active { background-color: var(--tool-active); border-color: #8f94fb; }
        .tool-btn.disabled { opacity: 0.4; cursor: not-allowed; }
        .tool-separator { width: 1px; height: 40px; background: var(--border-color); margin: 5px; }

        .icon-mask {
            display: inline-block;
            width: 32px; height: 32px;
            background-color: white; /* Warna Ikon Default */
            -webkit-mask-image: var(--icon-url); mask-image: var(--icon-url);
            -webkit-mask-size: contain; mask-size: contain;
            -webkit-mask-repeat: no-repeat; mask-repeat: no-repeat;
            -webkit-mask-position: center; mask-position: center;
        }
        .tool-btn.active .icon-mask { background-color: white; }
        .tool-btn:hover .icon-mask { background-color: #e0e0e0; }

        .actions-and-palette-container { gap: 20px; }
        .palette-swatches {
            display: flex; flex-wrap: wrap; gap: 10px; justify-content: center;
            padding-bottom: 20px; border-bottom: 1px solid var(--border-color); width: 100%;
        }
        .swatch-btn {
            width: 35px; height: 35px; border-radius: 8px; border: 2px solid var(--border-color);
            cursor: pointer; transition: transform 0.1s;
        }
        .swatch-btn:hover { transform: scale(1.1); }
        .main-action-buttons { display: flex; gap: 15px; justify-content: center; width: 100%; }
        .action-btn {
            padding: 12px 20px; border-radius: 8px; border: none;
            font-family: 'MinecraftTen', sans-serif; font-size: 1.0em; color: white;
            cursor: pointer; transition: transform 0.1s; min-width: 150px;
            text-shadow: 2px 2px 0px rgba(0,0,0,0.2);
        }
        .action-btn:active { transform: scale(0.95); }
        .action-btn.save { background-image: linear-gradient(135deg, #007bff, #00d4ff); }
        .action-btn.cancel { background-image: linear-gradient(135deg, #dc3545, #ff7851); }

        .color-picker-modal {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.5); display: flex;
            justify-content: center; align-items: center;
            z-index: 100; opacity: 1; transition: opacity 0.2s; pointer-events: auto;
        }
        .color-picker-modal.hidden { opacity: 0; pointer-events: none; }
        .color-picker-content {
            background: var(--container-bg); border-radius: 12px;
            width: 380px; max-width: 95%; padding: 20px; box-shadow: 0 5px 20px rgba(0,0,0,0.4);
            position: absolute;
        }
        .color-picker-header {
            display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;
            font-family: 'MinecraftTen', sans-serif; font-size: 1.2em;
            cursor: move; touch-action: none; user-select: none; padding-bottom: 15px; border-bottom: 1px solid var(--border-color);
        }
        .close-btn { cursor: pointer; font-size: 1.5em; line-height: 1; }
        .color-display { display: flex; gap: 10px; margin-bottom: 15px; height: 50px; }
        .color-preview { flex: 1; border-radius: 8px; }
        .sv-panel { width: 100%; height: 200px; position: relative; background: red; border-radius: 8px; cursor: crosshair; }
        .sv-panel .white, .sv-panel .black { position: absolute; top: 0; left: 0; right: 0; bottom: 0; border-radius: 8px; }
        .sv-panel .white { background: linear-gradient(to right, #fff, rgba(255,255,255,0)); }
        .sv-panel .black { background: linear-gradient(to top, #000, rgba(0,0,0,0)); }
        .sv-picker { position: absolute; width: 16px; height: 16px; border: 2px solid #fff; border-radius: 50%; transform: translate(-8px, -8px); box-shadow: 0 0 5px rgba(0,0,0,0.5); }
        .slider-group { display: flex; flex-direction: column; gap: 15px; margin-top: 15px; }
        .slider-container { position: relative; width: 100%; height: 16px; border-radius: 8px; cursor: pointer; }
        .slider-track { width: 100%; height: 100%; border-radius: 8px; }
        .slider-thumb { position: absolute; top: 50%; width: 20px; height: 20px; border: 2px solid #fff; border-radius: 50%; background: #888; transform: translate(-10px, -50%); box-shadow: 0 0 5px rgba(0,0,0,0.5); }
        #hue-slider .slider-track { background: linear-gradient(to right, #f00, #ff0, #0f0, #0ff, #00f, #f0f, #f00); }
        #alpha-slider .slider-track { background-image: linear-gradient(45deg, #808080 25%, transparent 25%), linear-gradient(-45deg, #808080 25%, transparent 25%), linear-gradient(45deg, transparent 75%, #808080 75%), linear-gradient(-45deg, transparent 75%, #808080 75%); background-size: 10px 10px; }
        #alpha-gradient { position: absolute; width: 100%; height: 100%; border-radius: 8px; }
        .color-inputs { display: grid; grid-template-columns: 1fr 2fr; gap: 8px; align-items: center; margin-top: 15px; font-size: 0.9em; }
        .color-inputs label { font-weight: bold; }
        .color-inputs input { width: 100%; background: var(--tool-bg); border: 1px solid var(--border-color); color: var(--text); border-radius: 5px; padding: 5px; text-align: center; }
    </style>
</head>
<body>
    <header class="editor-header">
        <h1>Glyph Pixel Editor</h1>
    </header>

    <main class="editor-main">
        <div class="editor-section canvas-container">
            <div id="canvas-grid-wrapper">
                <div id="canvas-grid-overlay"></div>
                <canvas id="editor-canvas"></canvas>
            </div>
        </div>
        <div class="editor-section tools-container">
            <div class="toolbar" id="toolbar"></div>
        </div>
        <div class="editor-section actions-and-palette-container">
            <div class="palette-swatches" id="palette-swatches"></div>
            <div class="main-action-buttons">
                <button id="save-btn" class="action-btn save">Save & Return</button>
                <button id="cancel-btn" class="action-btn cancel">Cancel</button>
            </div>
        </div>
    </main>
    
    <div id="color-picker-modal" class="color-picker-modal hidden">
        <div class="color-picker-content">
            <div class="color-picker-header" id="color-picker-header">
                <span>Color Picker</span>
                <span class="close-btn" id="close-color-picker">Ã—</span>
            </div>
            <div class="color-display"> <div id="old-color" class="color-preview old"></div> <div id="new-color" class="color-preview new"></div> </div>
            <div class="sv-panel" id="sv-panel"> <div class="white"></div><div class="black"></div> <div class="sv-picker" id="sv-picker"></div> </div>
            <div class="slider-group"> <div class="slider-container" id="hue-slider"> <div class="slider-track"></div> <div class="slider-thumb" id="hue-thumb"></div> </div> <div class="slider-container" id="alpha-slider"> <div class="slider-track"></div> <div id="alpha-gradient" class="slider-gradient"></div> <div class="slider-thumb" id="alpha-thumb"></div> </div> </div>
            <div class="color-inputs"> <label for="hex-input">HEX</label> <input type="text" id="hex-input"> <label for="r-input">R</label> <input type="number" id="r-input" min="0" max="255"> <label for="g-input">G</label> <input type="number" id="g-input" min="0" max="255"> <label for="b-input">B</label> <input type="number" id="b-input" min="0" max="255"> <label for="a-input">A</label> <input type="number" id="a-input" min="0" max="255"> </div>
        </div>
    </div>

<script>
    const canvas = document.getElementById('editor-canvas');
    const ctx = canvas.getContext('2d', { willReadFrequently: true });
    const gridWrapper = document.getElementById('canvas-grid-wrapper');
    const gridOverlay = document.getElementById('canvas-grid-overlay');
    const paletteSwatchesContainer = document.getElementById('palette-swatches');
    
    const state = {
        editData: null,
        activeTool: 'pencil',
        isDrawing: false,
        history: [],
        redoStack: [],
        maxHistory: 30,
        currentColor: 'rgba(255, 255, 255, 1)',
    };

    const tools = [
        { id: 'pencil', icon: `<span class="icon-mask" style="--icon-url: url('img/pencil.svg');"></span>`, title: 'Pencil (P)' },
        { id: 'picker', icon: `<span class="icon-mask" style="--icon-url: url('img/picker.svg');"></span>`, title: 'Eyedropper (I)' },
        { id: 'eraser', icon: `<span class="icon-mask" style="--icon-url: url('img/eraser.svg');"></span>`, title: 'Eraser (E)' },
        { id: 'bucket', icon: `<span class="icon-mask" style="--icon-url: url('img/bucket.svg');"></span>`, title: 'Bucket (B)' },
        { type: 'separator' },
        { id: 'undo', icon: `<span class="icon-mask" style="--icon-url: url('img/undo.svg');"></span>`, title: 'Undo (Ctrl+Z)' },
        { id: 'redo', icon: `<span class="icon-mask" style="--icon-url: url('img/redo.svg');"></span>`, title: 'Redo (Ctrl+Y)' },
        { type: 'separator' },
        { id: 'palette', icon: `<span class="icon-mask" style="--icon-url: url('img/palette.svg');"></span>`, title: 'Color Palette (C)' },
    ];
    
    function createToolbar() {
        const toolbar = document.getElementById('toolbar');
        toolbar.innerHTML = '';
        tools.forEach(tool => {
            if (tool.type === 'separator') {
                const sep = document.createElement('div'); sep.className = 'tool-separator'; toolbar.appendChild(sep); return;
            }
            const btn = document.createElement('button');
            btn.className = 'tool-btn'; btn.id = `tool-${tool.id}`; btn.dataset.tool = tool.id; btn.title = tool.title; btn.innerHTML = tool.icon;
            toolbar.appendChild(btn);
        });
        updateToolButtons();
    }
    
    function updateToolButtons() {
        document.querySelectorAll('.tool-btn').forEach(btn => {
            btn.classList.toggle('active', btn.dataset.tool === state.activeTool);
        });
        document.getElementById('tool-undo').classList.toggle('disabled', state.history.length <= 1);
        document.getElementById('tool-redo').classList.toggle('disabled', state.redoStack.length === 0);
    }
    
    window.onload = () => {
        const data = sessionStorage.getItem('editData');
        if (!data) { 
            console.log("No session data, initializing demo canvas (16x16)");
            setupCanvas(16, 16);
            return;
        }

        state.editData = JSON.parse(data);
        const img = new Image();
        img.onload = () => {
            setupCanvas(img.width, img.height);
            ctx.drawImage(img, 0, 0);
            saveHistory();
        };
        img.src = state.editData.imageData;
        
        createToolbar();
        renderPaletteSwatches();
        addEventListeners();
        initColorPicker();
    };

    function setupCanvas(width, height) {
        canvas.width = width;
        canvas.height = height;

        const wrapperWidth = gridWrapper.offsetWidth; // Misal 512px
        const pixelScale = wrapperWidth / width;      // Misal 512 / 16 = 32px per pixel

        gridWrapper.style.setProperty('--pixel-scale', `${pixelScale}px`);

        if (pixelScale >= 10) {
            gridOverlay.style.display = 'block';
        } else {
            gridOverlay.style.display = 'none';
        }

        saveHistory();
    }

    function getCanvasCoords(e) {
        let event = e;
        if (e.touches && e.touches.length > 0) { event = e.touches[0]; }
        const rect = canvas.getBoundingClientRect();
        const scaleX = canvas.width / rect.width; const scaleY = canvas.height / rect.height;
        const x = (event.clientX - rect.left) * scaleX; const y = (event.clientY - rect.top) * scaleY;
        return { x: Math.floor(x), y: Math.floor(y) };
    }

    function addEventListeners() {
        document.getElementById('save-btn').addEventListener('click', saveAndReturn);
        document.getElementById('cancel-btn').addEventListener('click', () => window.location.href = 'index.html');
        document.getElementById('toolbar').addEventListener('click', handleToolbarClick);
        canvas.addEventListener('mousedown', onDrawStart);
        canvas.addEventListener('touchstart', onDrawStart, { passive: false });
        window.addEventListener('keydown', onKeyDown);
    }
    
    function onDrawStart(e) {
        e.preventDefault();
        if (e.target.closest('.color-picker-modal')) return;
        state.isDrawing = true;
        const pos = getCanvasCoords(e);
        handleDrawing(pos.x, pos.y);

        if (e.type === 'mousedown') {
            window.addEventListener('mousemove', onDrawMove);
            window.addEventListener('mouseup', onDrawEnd);
        } else {
            window.addEventListener('touchmove', onDrawMove, { passive: false });
            window.addEventListener('touchend', onDrawEnd);
        }
    }
    function onDrawMove(e) {
        e.preventDefault();
        if (!state.isDrawing) return;
        const pos = getCanvasCoords(e);
        handleDrawing(pos.x, pos.y);
    }
    function onDrawEnd() {
        if (state.isDrawing) {
            saveHistory();
            addRecentColor(state.currentColor);
        }
        state.isDrawing = false;
        window.removeEventListener('mousemove', onDrawMove);
        window.removeEventListener('mouseup', onDrawEnd);
        window.removeEventListener('touchmove', onDrawMove);
        window.removeEventListener('touchend', onDrawEnd);
    }
    function onKeyDown(e) {
        if (e.ctrlKey && e.key === 'z') { e.preventDefault(); undo(); }
        if (e.ctrlKey && e.key === 'y') { e.preventDefault(); redo(); }
        const keyMap = { 'p': 'pencil', 'i': 'picker', 'e': 'eraser', 'b': 'bucket', 'c': 'palette' };
        if (document.activeElement.tagName === 'INPUT') return;
        if (keyMap[e.key]) {
            e.preventDefault();
            const tool = keyMap[e.key];
            if (tool === 'palette') { toggleColorPicker(); }
            else { state.activeTool = tool; }
            updateToolButtons();
        }
    }
    function handleToolbarClick(e) {
        const btn = e.target.closest('.tool-btn');
        if (!btn || btn.classList.contains('disabled')) return;
        const tool = btn.dataset.tool;
        if (tool === 'undo') { undo(); }
        else if (tool === 'redo') { redo(); }
        else if (tool === 'palette') { toggleColorPicker(); }
        else { state.activeTool = tool; }
        updateToolButtons();
    }
    
    function handleDrawing(x, y) {
        if (x < 0 || x >= canvas.width || y < 0 || y >= canvas.height) return;
        switch (state.activeTool) {
            case 'pencil': ctx.fillStyle = state.currentColor; ctx.fillRect(x, y, 1, 1); break;
            case 'eraser': ctx.clearRect(x, y, 1, 1); break;
            case 'picker':
                if (!state.isDrawing) return;
                const pixel = ctx.getImageData(x, y, 1, 1).data;
                const rgba = `rgba(${pixel[0]}, ${pixel[1]}, ${pixel[2]}, ${pixel[3] / 255})`;
                state.currentColor = rgba; 
                addRecentColor(rgba);
                updateColorPicker(rgbaToHsv(pixel[0], pixel[1], pixel[2], pixel[3])); 
                state.isDrawing = false;
                break;
            case 'bucket':
                if (state.isDrawing) { floodFill(x, y, parseRgba(state.currentColor)); state.isDrawing = false; } break;
        }
    }
    function floodFill(startX, startY, fillColor) {
        const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height); const data = imageData.data;
        const startPos = (startY * canvas.width + startX) * 4;
        const startColor = [data[startPos], data[startPos + 1], data[startPos + 2], data[startPos + 3]];
        if (colorsMatch(startColor, fillColor)) return;
        const queue = [[startX, startY]];
        while (queue.length > 0) {
            const [x, y] = queue.shift();
            if (x < 0 || x >= canvas.width || y < 0 || y >= canvas.height) continue;
            const currentPos = (y * canvas.width + x) * 4;
            const currentColor = [data[currentPos], data[currentPos+1], data[currentPos+2], data[currentPos+3]];
            if (colorsMatch(currentColor, startColor)) {
                data[currentPos] = fillColor[0]; data[currentPos + 1] = fillColor[1];
                data[currentPos + 2] = fillColor[2]; data[currentPos + 3] = fillColor[3];
                queue.push([x + 1, y]); queue.push([x - 1, y]); queue.push([x, y + 1]); queue.push([x, y - 1]);
            }
        }
        ctx.putImageData(imageData, 0, 0);
    }
    
    function saveHistory() {
        if (state.history.length >= state.maxHistory) { state.history.shift(); }
        state.history.push(ctx.getImageData(0, 0, canvas.width, canvas.height));
        state.redoStack = []; updateToolButtons();
    }
    function undo() {
        if (state.history.length <= 1) return;
        state.redoStack.push(state.history.pop());
        const lastState = state.history[state.history.length - 1];
        ctx.putImageData(lastState, 0, 0); updateToolButtons();
    }
    function redo() {
        if (state.redoStack.length === 0) return;
        const nextState = state.redoStack.pop();
        state.history.push(nextState); ctx.putImageData(nextState, 0, 0); updateToolButtons();
    }

    function saveAndReturn() {
        if (state.editData) {
            const editedGlyphs = JSON.parse(localStorage.getItem('editedGlyphs')) || {};
            const tileKey = `${state.editData.row}-${state.editData.col}`;
            editedGlyphs[tileKey] = canvas.toDataURL();
            localStorage.setItem('editedGlyphs', JSON.stringify(editedGlyphs));
        }
        window.location.href = 'index.html';
    }

    function addRecentColor(color) {
        let recentColors = JSON.parse(localStorage.getItem('recentColors')) || [];
        recentColors = recentColors.filter(c => c !== color);
        recentColors.unshift(color);
        if (recentColors.length > 10) { recentColors = recentColors.slice(0, 10); }
        localStorage.setItem('recentColors', JSON.stringify(recentColors));
        renderPaletteSwatches();
    }
    function renderPaletteSwatches() {
        const recentColors = JSON.parse(localStorage.getItem('recentColors')) || [];
        paletteSwatchesContainer.innerHTML = '';
        recentColors.forEach(color => {
            const swatch = document.createElement('button');
            swatch.className = 'swatch-btn';
            swatch.style.backgroundColor = color;
            swatch.addEventListener('click', () => {
                state.currentColor = color;
                addRecentColor(color);
                const rgba = parseRgba(color);
                updateColorPicker(rgbaToHsv(rgba[0], rgba[1], rgba[2], rgba[3]));
            });
            paletteSwatchesContainer.appendChild(swatch);
        });
    }

    const cp = {
        modal: document.getElementById('color-picker-modal'),
        content: document.querySelector('.color-picker-content'),
        header: document.getElementById('color-picker-header'),
        svPanel: document.getElementById('sv-panel'), svPicker: document.getElementById('sv-picker'),
        hueSlider: document.getElementById('hue-slider'), hueThumb: document.getElementById('hue-thumb'),
        alphaSlider: document.getElementById('alpha-slider'), alphaThumb: document.getElementById('alpha-thumb'),
        alphaGradient: document.getElementById('alpha-gradient'), oldColor: document.getElementById('old-color'),
        newColor: document.getElementById('new-color'), hexInput: document.getElementById('hex-input'),
        rInput: document.getElementById('r-input'), gInput: document.getElementById('g-input'),
        bInput: document.getElementById('b-input'), aInput: document.getElementById('a-input'),
        hue: 0, sat: 1, val: 1, alpha: 1,
    };
    function initColorPicker() {
        document.getElementById('close-color-picker').addEventListener('click', toggleColorPicker);
        let isDragging = false; let offsetX, offsetY;
        
        const onDragStart = (e) => {
            let event = e.touches ? e.touches[0] : e;
            isDragging = true;
            const rect = cp.content.getBoundingClientRect();
            offsetX = event.clientX - rect.left;
            offsetY = event.clientY - rect.top;
        };
        const onDragMove = (e) => {
            if (!isDragging) return;
            e.preventDefault();
            let event = e.touches ? e.touches[0] : e;
            cp.content.style.left = `${event.clientX - offsetX}px`;
            cp.content.style.top = `${event.clientY - offsetY}px`;
        };
        const onDragEnd = () => { isDragging = false; };
        
        cp.header.addEventListener('mousedown', onDragStart);
        window.addEventListener('mousemove', onDragMove);
        window.addEventListener('mouseup', onDragEnd);
        cp.header.addEventListener('touchstart', onDragStart, { passive: false });
        window.addEventListener('touchmove', onDragMove, { passive: false });
        window.addEventListener('touchend', onDragEnd);
        
        const sliders = [ { el: cp.svPanel, handler: handleSvDrag }, { el: cp.hueSlider, handler: handleHueDrag }, { el: cp.alphaSlider, handler: handleAlphaDrag } ];
        sliders.forEach(s => {
            const sliderStart = (e) => { e.preventDefault(); s.handler(e);
                const sliderMove = (moveEvent) => s.handler(moveEvent);
                const sliderEnd = () => {
                    window.removeEventListener('mousemove', sliderMove); window.removeEventListener('mouseup', sliderEnd);
                    window.removeEventListener('touchmove', sliderMove); window.removeEventListener('touchend', sliderEnd);
                };
                window.addEventListener('mousemove', sliderMove); window.addEventListener('mouseup', sliderEnd);
                window.addEventListener('touchmove', sliderMove, { passive: false }); window.addEventListener('touchend', sliderEnd);
            };
            s.el.addEventListener('mousedown', sliderStart); s.el.addEventListener('touchstart', sliderStart, { passive: false });
        });
        [cp.rInput, cp.gInput, cp.bInput, cp.aInput, cp.hexInput].forEach(input => { input.addEventListener('change', handleInputChange); });
    }
    function toggleColorPicker() {
        cp.modal.classList.toggle('hidden');
        if (!cp.modal.classList.contains('hidden')) {
            cp.content.style.position = 'absolute'; cp.content.style.left = '50%'; cp.content.style.top = '50%';
            cp.content.style.transform = 'translate(-50%, -50%)';
            const rgba = parseRgba(state.currentColor);
            const hsv = rgbaToHsv(rgba[0], rgba[1], rgba[2], rgba[3]);
            cp.oldColor.style.background = state.currentColor;
            updateColorPicker(hsv);
        }
    }
    function updateColorPicker(hsv = null) {
        if (hsv) { cp.hue = hsv.h; cp.sat = hsv.s; cp.val = hsv.v; if (hsv.a !== undefined) cp.alpha = hsv.a; }
        const rgb = hsvToRgb(cp.hue, cp.sat, cp.val);
        const rgba = `rgba(${rgb.r}, ${rgb.g}, ${rgb.b}, ${cp.alpha})`; 
        state.currentColor = rgba;
        cp.svPanel.style.backgroundColor = `hsl(${cp.hue * 360}, 100%, 50%)`;
        cp.svPicker.style.left = `${cp.sat * 100}%`; cp.svPicker.style.top = `${(1 - cp.val) * 100}%`;
        cp.hueThumb.style.left = `${cp.hue * 100}%`; cp.alphaThumb.style.left = `${cp.alpha * 100}%`;
        cp.alphaGradient.style.background = `linear-gradient(to right, rgba(${rgb.r},${rgb.g},${rgb.b},0), rgb(${rgb.r},${rgb.g},${rgb.b}))`;
        cp.newColor.style.background = rgba;
        cp.rInput.value = rgb.r; cp.gInput.value = rgb.g; cp.bInput.value = rgb.b;
        cp.aInput.value = Math.round(cp.alpha * 255); cp.hexInput.value = rgbToHex(rgb.r, rgb.g, rgb.b);
    }
    function handleSvDrag(e) { let event = e.touches ? e.touches[0] : e; const rect = cp.svPanel.getBoundingClientRect(); let x = (event.clientX - rect.left) / rect.width; let y = (event.clientY - rect.top) / rect.height; x = Math.max(0, Math.min(1, x)); y = Math.max(0, Math.min(1, y)); cp.sat = x; cp.val = 1 - y; updateColorPicker(); }
    function handleHueDrag(e) { let event = e.touches ? e.touches[0] : e; const rect = cp.hueSlider.getBoundingClientRect(); let x = (event.clientX - rect.left) / rect.width; cp.hue = Math.max(0, Math.min(1, x)); updateColorPicker(); }
    function handleAlphaDrag(e) { let event = e.touches ? e.touches[0] : e; const rect = cp.alphaSlider.getBoundingClientRect(); let x = (event.clientX - rect.left) / rect.width; cp.alpha = Math.max(0, Math.min(1, x)); updateColorPicker(); }
    function handleInputChange() {
        let rgba;
        if (this === cp.hexInput) { rgba = hexToRgba(this.value); }
        else { rgba = [parseInt(cp.rInput.value), parseInt(cp.gInput.value), parseInt(cp.bInput.value), parseInt(cp.aInput.value)]; }
        if (rgba.some(isNaN)) return;
        const hsv = rgbaToHsv(rgba[0], rgba[1], rgba[2], rgba.length > 3 ? rgba[3] * 255 : 255); updateColorPicker(hsv);
    }
    function colorsMatch(c1, c2) { return c1[0] === c2[0] && c1[1] === c2[1] && c1[2] === c2[2] && c1[3] === c2[3]; }
    function parseRgba(rgbaString) { const arr = rgbaString.substring(rgbaString.indexOf('(') + 1, rgbaString.lastIndexOf(')')).split(','); return [parseInt(arr[0]), parseInt(arr[1]), parseInt(arr[2]), arr[3] ? Math.round(parseFloat(arr[3]) * 255) : 255]; }
    function hsvToRgb(h, s, v) { let r, g, b, i, f, p, q, t; i = Math.floor(h * 6); f = h * 6 - i; p = v * (1 - s); q = v * (1 - f * s); t = v * (1 - (1 - f) * s); switch (i % 6) { case 0: r = v, g = t, b = p; break; case 1: r = q, g = v, b = p; break; case 2: r = p, g = v, b = t; break; case 3: r = p, g = q, b = v; break; case 4: r = t, g = p, b = v; break; case 5: r = v, g = p, b = q; break; } return { r: Math.round(r * 255), g: Math.round(g * 255), b: Math.round(b * 255) }; }
    function rgbaToHsv(r, g, b, a) { r /= 255, g /= 255, b /= 255; let max = Math.max(r, g, b), min = Math.min(r, g, b), h, s, v = max, d = max - min; s = max == 0 ? 0 : d / max; if (max == min) { h = 0; } else { switch (max) { case r: h = (g - b) / d + (g < b ? 6 : 0); break; case g: h = (b - r) / d + 2; break; case b: h = (r - g) / d + 4; break; } h /= 6; } return { h, s, v, a: a / 255 }; }
    function rgbToHex(r, g, b) { return "#" + ((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1).toUpperCase(); }
    function hexToRgba(hex) { let c; if (/^#([A-Fa-f0-9]{3}){1,2}$/.test(hex)) { c = hex.substring(1).split(''); if (c.length == 3) { c = [c[0], c[0], c[1], c[1], c[2], c[2]]; } c = '0x' + c.join(''); return [(c >> 16) & 255, (c >> 8) & 255, c & 255]; } return [0, 0, 0]; }
</script>
</body>
</html>
